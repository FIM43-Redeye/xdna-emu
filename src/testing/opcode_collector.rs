//! Unknown opcode collection for iterative instruction implementation.
//!
//! This module provides utilities for tracking which instructions fail during
//! execution, enabling a fail-fast development workflow.

use std::collections::HashMap;
use crate::interpreter::bundle::SlotIndex;

/// An unknown instruction encountered during execution.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnknownOpcode {
    /// The slot where the instruction was found.
    pub slot: SlotIndex,
    /// Raw opcode bits.
    pub opcode: u32,
    /// Program counter where it was encountered.
    pub pc: u32,
    /// Tile coordinates (col, row).
    pub tile: (u8, u8),
    /// Mnemonic hint from decoder (if available).
    pub mnemonic: Option<String>,
}

impl UnknownOpcode {
    /// Parse from an error message generated by the executor.
    ///
    /// Error format: "Unknown instruction opcode 0x{:08X} at slot {:?}"
    pub fn from_error_message(message: &str, pc: u32, tile: (u8, u8)) -> Option<Self> {
        // Parse: "Unknown instruction opcode 0xNNNNNNNN at slot Xxx"
        if !message.starts_with("Unknown instruction opcode") {
            return None;
        }

        // Extract opcode
        let opcode_start = message.find("0x")?;
        let opcode_end = opcode_start + 10; // "0x" + 8 hex digits
        let opcode_str = message.get(opcode_start + 2..opcode_end)?;
        let opcode = u32::from_str_radix(opcode_str, 16).ok()?;

        // Extract slot
        let slot = if message.contains("Scalar0") {
            SlotIndex::Scalar0
        } else if message.contains("Scalar1") {
            SlotIndex::Scalar1
        } else if message.contains("Vector") {
            SlotIndex::Vector
        } else if message.contains("Load") {
            SlotIndex::Load
        } else if message.contains("Store") {
            SlotIndex::Store
        } else if message.contains("Control") {
            SlotIndex::Control
        } else if message.contains("Accumulator") {
            SlotIndex::Accumulator
        } else {
            // Default to Scalar0 if unknown
            SlotIndex::Scalar0
        };

        Some(UnknownOpcode {
            slot,
            opcode,
            pc,
            tile,
            mnemonic: None,
        })
    }
}

/// Collection of unknown opcodes encountered during test runs.
#[derive(Debug, Default)]
pub struct OpcodeCollector {
    /// Unknown opcodes with their occurrence counts.
    pub unknowns: HashMap<(SlotIndex, u32), UnknownOpcodeStats>,
    /// Total number of unknown opcode hits.
    pub total_hits: usize,
}

/// Statistics for a single unknown opcode.
#[derive(Debug, Clone)]
pub struct UnknownOpcodeStats {
    /// First occurrence details.
    pub first: UnknownOpcode,
    /// Number of times this opcode was encountered.
    pub count: usize,
    /// Test names where this was encountered.
    pub tests: Vec<String>,
}

impl OpcodeCollector {
    /// Create a new collector.
    pub fn new() -> Self {
        Self::default()
    }

    /// Record an unknown opcode.
    pub fn record(&mut self, opcode: UnknownOpcode, test_name: &str) {
        let key = (opcode.slot, opcode.opcode);
        self.total_hits += 1;

        if let Some(stats) = self.unknowns.get_mut(&key) {
            stats.count += 1;
            if !stats.tests.contains(&test_name.to_string()) {
                stats.tests.push(test_name.to_string());
            }
        } else {
            self.unknowns.insert(
                key,
                UnknownOpcodeStats {
                    first: opcode,
                    count: 1,
                    tests: vec![test_name.to_string()],
                },
            );
        }
    }

    /// Get unknown opcodes sorted by how many tests they block.
    pub fn by_impact(&self) -> Vec<&UnknownOpcodeStats> {
        let mut stats: Vec<_> = self.unknowns.values().collect();
        stats.sort_by(|a, b| b.tests.len().cmp(&a.tests.len()));
        stats
    }

    /// Generate a priority report for implementation.
    pub fn priority_report(&self) -> String {
        let mut report = String::new();
        report.push_str("=== Unknown Opcode Priority List ===\n\n");

        let sorted = self.by_impact();
        for (i, stats) in sorted.iter().enumerate() {
            report.push_str(&format!(
                "{}. Slot {:?}, opcode 0x{:08X}\n",
                i + 1,
                stats.first.slot,
                stats.first.opcode
            ));
            report.push_str(&format!(
                "   Blocks {} tests, hit {} times\n",
                stats.tests.len(),
                stats.count
            ));
            if let Some(ref mnemonic) = stats.first.mnemonic {
                report.push_str(&format!("   Mnemonic hint: {}\n", mnemonic));
            }
            report.push_str(&format!(
                "   First seen: PC=0x{:04X} in tile({},{})\n",
                stats.first.pc, stats.first.tile.0, stats.first.tile.1
            ));
            report.push_str(&format!("   Tests: {:?}\n\n", stats.tests));
        }

        report
    }

    /// Check if any unknowns were encountered.
    pub fn has_unknowns(&self) -> bool {
        !self.unknowns.is_empty()
    }

    /// Get number of unique unknown opcodes.
    pub fn unique_count(&self) -> usize {
        self.unknowns.len()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_error_message() {
        let message = "Unknown instruction opcode 0x00001234 at slot Scalar0";
        let opcode = UnknownOpcode::from_error_message(message, 0x100, (0, 2));

        assert!(opcode.is_some());
        let opcode = opcode.unwrap();
        assert_eq!(opcode.opcode, 0x1234);
        assert_eq!(opcode.slot, SlotIndex::Scalar0);
        assert_eq!(opcode.pc, 0x100);
        assert_eq!(opcode.tile, (0, 2));
    }

    #[test]
    fn test_collector_priority() {
        let mut collector = OpcodeCollector::new();

        // Record same opcode from multiple tests
        for test in &["test1", "test2", "test3"] {
            collector.record(
                UnknownOpcode {
                    slot: SlotIndex::Scalar0,
                    opcode: 0xABCD,
                    pc: 0x100,
                    tile: (0, 2),
                    mnemonic: None,
                },
                test,
            );
        }

        // Record another opcode from one test
        collector.record(
            UnknownOpcode {
                slot: SlotIndex::Vector,
                opcode: 0x1234,
                pc: 0x200,
                tile: (0, 2),
                mnemonic: None,
            },
            "test1",
        );

        let by_impact = collector.by_impact();
        // 0xABCD should be first (blocks 3 tests)
        assert_eq!(by_impact[0].first.opcode, 0xABCD);
        assert_eq!(by_impact[0].tests.len(), 3);
        // 0x1234 should be second (blocks 1 test)
        assert_eq!(by_impact[1].first.opcode, 0x1234);
        assert_eq!(by_impact[1].tests.len(), 1);
    }
}
